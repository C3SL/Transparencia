#!/usr/bin/env python3

# WARNING: This script should not be called if you dont know what you're doing! Look for 'insert_expenses.sh'.

# Input: A configuration file, in the same format as the example. This configuration file can be generated by create_expenses_config.py.

# Documentation of config.json.example:
# - Variables ending with number 1 represent something from the first file, while the ones that end with number 2 represent the same thing in the second file.
# - File1 and File2 are the files that will be merged. File1 name is "*_Cadastro_Unique.csv", File2 name is "*_Remuneracao.csv".
# - Encoding1 and Enconding2 are the encoding from CSV files 1 and 2, respectively. If you dont know which one you should use, try utf-8.
# - IdColumn1 and IdColumn2 represent the common column for each CSV (Ex: an ID column).
# - IgnoreColumns1 and IgnoreColumns2 are arrays to prevent from getting some columns from the CSV (you may want to use this to prevent having duplicate columns, like the ID column used to merge the CSVs).
# - Quotechar, Delimiter and LineTerminator are the CSV's quote char, delimiter and line terminator, respectively.
# - OutputFile is the name of the output file (the result CSV).

# Script made to create a CSV that will be inserted in ElasticSearch.
# It works by getting a Config File as defined above and making the equivalent of a "Left outer join", grabbing all data from File2 and the data requested from File1.

# Output: A CSV that will contain every row from File2 and get all the data it can from File1.

import sys, csv, json, math, subprocess
from pathlib import Path
from subprocess import call

if len(sys.argv) != 4:
    print("Usage: " + sys.argv[0] + " <config.json> <filter> <columnId>")
    sys.exit()

with open(sys.argv[1]) as f:
    params = json.load(f)

# Which files should be merged?
file1 = params['path'] + '/' + params['date'] + params['file1']
file2 = params['path'] + '/' + params['date'] + params['file2']

# What are the file encodings?
encoding1 = params['encoding1']
encoding2 = params['encoding2']

# Which column in each file contains the common column?
idPointColumn1 = params['idColumn1']
idPointColumn2 = params['idColumn2']

# Which columns should be ignored? (Usually the idColumn, since its in both files and you probably wont want duplicated data.)
ignoreColumns1 = params['ignoreColumns1']
ignoreColumns2 = params['ignoreColumns2']

csv.register_dialect('dialect', lineterminator = params['lineterminator'], delimiter=params['delimiter'], quoting=csv.QUOTE_NONE)

file_exists = Path(file1)
if not file_exists.is_file():
    print("File " + file1 + " does not exist. Aborting...")
    sys.exit()

with open(file1, newline='', encoding=encoding1) as f:
    csv_1 = [ i for i in csv.reader(f, 'dialect') ]
title1 = csv_1.pop(0)

file_exists = Path(file2)
if not file_exists.is_file():
    print("File " + file2 + " does not exist. Aborting...")
    sys.exit()

with open(file2, newline='', encoding=encoding2) as f:
    csv_2 = [ i for i in csv.reader(f, 'dialect') ]
title2 = csv_2.pop(0)

# Having data from both files, I have to merge them.

def getDataFromRows(row1, row2):
    newRow = []
    for i in range(0, len(row2)):
        if i in ignoreColumns2:
            continue
        newRow.append(row2[i])
    for i in range(0, len(row1)):
        if i in ignoreColumns1:
            continue
        newRow.append(row1[i])
    return newRow

def getDataWithEmptyRow(columns, row):
    newRow = []
    for i in range(0, len(row)):
        if i in ignoreColumns2:
            continue
        newRow.append(row[i])
    for i in range(0, columns):
        if i in ignoreColumns1:
            continue
        newRow.append('')
    return newRow

result = []
hits = 0
errors = 0

# Get number of columns in file 1
columns1 = len(csv_1[0])

# Create dictionary...
data = {}
for row in csv_1:
    data[row[idPointColumn1]] = row

for row2 in csv_2:
    if row2[idPointColumn2] in data:
        newRow = getDataFromRows(data[row2[idPointColumn2]], row2)
        result.append(newRow)
        hits += 1
    else:
        # This guy was in the second file, but not in the first one. Add him, but with null values in the second file.
        newRow = getDataWithEmptyRow(columns1, row2)
        result.append(newRow)
        errors += 1

with open(params['outputFile'], 'w', newline='') as csvfile:
    writer = csv.writer(csvfile, delimiter='\t')
    writer.writerow(getDataFromRows(title1, title2))
    writer.writerows(result)
